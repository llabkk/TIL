### 컴퓨팅 사고력
#### 프로그래밍과 논리/수학
논리(Hard Logic)
- 생각이나 주장의 타당성이 옳고 그름을 판별하는 규칙이나 원리를 의미
- 경험적, 직관적, 확률적 판단을 의미하는 soft logic, 반대되는 의미로 hard logic
- 맞는 이유와 틀린 이유를 정확히 밝히는 생각의 규칙

프로그래밍의 어려운 점
- 프로그래밍 언어 문법과 라이브러리 사용
  - 처음 보는 사람은 알 수 없음
  - 훈련에 비례하여 실력이 늘게 됨
- 논리
  - 직관적인 접근을 논리로 착각하기 쉬움

카드 문제
- 직관으로 접근하면 어려운 문제
- 사실: 모든 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음
- 주장: 한쪽이 D이면 반대쪽은 3

- 주장이 사실인지 확인하기 위해 다음 카드들 중 반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?(D인 알파벳 카드, 3이 아닌 숫자 카드)

맥주집 문제
- 규칙: 20세 이하인 사람은 맥주를 마실 수 없음
- 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇 명이고 누구인가?(17, 31, 콜라, 맥주)
- 답(17세, 맥주)

카드 문제와 맥주집 문제의 비교
- 맥주집 문제가 훨씬 풀기 쉽다
  - 사실, 두 문제는 완전히 같은 문제. 즉, 논리적 구성이 완전히 동일
- 왜 맥주집 문제가 풀기 쉬운가?
  - 논리 구조를 정확히 이해하고 맥주집 문제를 푸는 사람은 카드 문제를 똑같이 풀 수 있음
  - 맥주집 문제를 풀 때 논리를 사용한 것이 아님

Soft Logic
- 맥주집 문제를 풀 때 직관을 사용한 것과 같은 경우
- 직관은 논리적인 느낌을 주는 것
- 직관의 장점은 (익순한 상황에서) 빠름
- 직관의 단점은 **정확하지 않음 (가끔은 익숙한 상황에서도 틀림)**
- 또 다른 단점은 **강한 착각을 일으킨다는 것**

Hard Logic vs Soft Logic
- 일상 생활
  - Soft Logic이 빠르기 때문에 유용
  - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 알고 있다는 가정이 존재
- 프로그래밍
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요

명제
- 참이나 거짓을 알 수 있는 식이나 문장
- p, q, r, ...로 표현
- 진릿값
  - 참이나 거짓을 표현
  - T, F 또는 1, 0

명제의 연산(결합)
- 부정(NOT)
  - p가 명제일 때, 명제의 진릿값이 반대가 됨
  - ~p로 표기하고, not p 또는 p의 부정으로 읽음
- 논리곱(AND)
  - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
  - p^q로 표기, p and q 또는 p 그리고 q로 읽음
- 논리 합(OR)
  - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
  - p V q로 표기하고 p or q나 p 또는 q로 읽음
- 배타적 논리합(XOR)
  - p, q가 명제일 때, p, q중 하나만 참일 때만 참이 되는 명제
  - pq로 표기하고, p xor q 또는 p exclusive OR q로 읽음
- 조건명제
  - p, q가 명제일 때, 명제 p가 조건(원인), q기 결론(결과)으로 제시되는 명제
  - p → q (p이면 q이다)
- 쌍방조건명제
  - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
  - p ↔ q(p면 q고, q면 p다)

p|q|p^q|p V q|pq
:---:|:---:|:---:|:---:|:---:
T|T|T|T|F
T|F|F|T|T
F|T|F|T|T
F|F|F|F|F

p|q|~p|p → q|p ↔ q 
:---:|:---:|:---:|:---:|:---:
T|T|F|T|F
T|F|F|F|T
F|T|T|F|T
F|F|T|T|F

조건 명제의 역, 이, 대우
  - 주어진 명제: p → q
  - 역: q → p
  - 이: ~p → ~q
  - 대우: ~q → ~p

증명
- 직접 증명
  - p → q가 참임을 증명하기 위해 p를 참으로 가정했을 때 q도 참임을 증명하는 방법
  - 자명한 증명, q가 항상 참인 경우
  - 공허한 증명, p가 항상 거짓인 경우
- 간접 증명
  - 증명해야 하는 명제를 변형하여 증명하는 방법
  - 대우에 의한 증명
  - 모순에 의한 증명
- 수학적 귀납법
  - 일정한 규칙을 나타내는 명제 P(n)이 성립함을 증명하는 방법

#### 논리와 증명
항진명제(U) : 명제의 진릿값과 무관하게 항상 참인 명제
모순명제(φ) : 명제의 진릿값과 무관하게 항상 거짓인 명제


#### 수와 표현
- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2**k - 1까지 표현 가능
- 약속하는 방식에 따라 최대 2**k가지의 값을 표현하는 것이 가능
- 10진수로 k자리를 쓰면 0부터 10**k - 1까지 표현이 가능한 것과 완전히 동일한 과정
- 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
  - 2\*\*k - 1 >= n이 성립해야 한다. 즉, 2\*\*k >= n+1
  - 같은 의미로, k>=log(n+1), 약 log n비트가 필요
- x = log n과 2**x = n은 같은 말

log n 이란
- 2의 몇 승이 n이 되는가의 답
- n을 표현하는 데 몇 비트가 필요한가의 답
- 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되는가의 답
- n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되는가의 답
- x=log n일 때 x와 n을 비교하면 x가 더 작고, n이 커질수록 차이는 더 커짐
- 컴퓨터 분야에서 로그의 밑은 항상 2

- 32비트 컴퓨터의 주소 공간은 2**32 = 약 40억개

#### 집합과 조합론
집합과 조합론에 대한 약간의 설명
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분 집합이고 B가 A의 부분집합임을 증명하면 된다.

- 귀류법 : 간접증명의 한 방식
  - 한 명제가 참인 것을 증명하려고 할 때에, 그 명제의 부정을 참이라고 가정하여 거기에서 나타나는 불합리성을 증명함으로써 원래의 명제가 참인 것을 보여주는 증명법 또는 p^~q를 증명하는 방법
#### 기초수식
- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재함
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있음
- 재귀식을 O() notation 수준으로 풀어보는 연습이 필요

#### 재귀
- 재귀한 자기 자신을 호출하는 함수
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 끝나지 않으므로 다른 입력으로 호출
- 함수란 어떤 문제를 해결하는 방법을 코딩한 것
- 함수가 어떤 문제의 모든 케이스를 해결해야 함
- 수학적 귀납법 증명 사용 가능
- 순차적인 코드에서 일어나는 계산과 완전히 동일, 다만 표현하는 방법이 달라진 것
- 다르게 생각하는 방법
  - 어떤 문제를 해결하려다 부분 문제를 만났는데, 원래 해결하려던 입력 케이스와 동일한 문제에 속하지만 "크기가 더 작은" 입력 케이스를 해결하는 것이 그 부분 문제 → 즉, 부분 문제가 동일한 문제인 경우

  재귀에 대한 연습
  - 재귀 알고리즘을 슈도코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행

#### 동적 계획법
- 간단하게 설명하면 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것(Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 함
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수 있음(Dynamic Programing)
- 동적 계획법 알고리즘을 슈도코드로 작성하고, 정확성 증명 및 시간 복잡도를 계산하는 연습이 필요함