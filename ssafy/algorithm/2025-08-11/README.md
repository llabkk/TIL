### 문자열
#### 연산
문자열 뒤집기
- 문자열을 역순으로 재정의
```python
s = 'Reverse this strings'
s = s[::-1]   # sgnirts siht esreveR
```

- 리스트로 변환 후 다시 문자열로 변환
```python
s = 'abcd'
s = list(s)
s.reverse()
s = "".join(s)
```

회문
- "기러기", "토마토", "스위스"와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 낱말
  - 문자열 길이의 반만 비교하면 됨
```python
is_palindrome(txt):
    for i in range(len(txt)//2):
        if txt[i] != txt[len(txt)-i]:
            return False
    return True
```

문자열 비교
- ==연산자와 is연산자
  - ==는 값(value)이 같은지를 비교
  - is는 객체의 정체성(idntity), 즉 **같은 객체(메모리 주소)**인지 비교
  - ==연산자는 내부적으로 특수 메서드 __eq__()를 호출
```python
# String의 경우
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = s1
s5 = s1[:2] + 'c'

print(s1 == s2)   # True
print(s1 is s2)   # True
print(s4 == s5)   # True
print(s4 is s5)   # False

# list의 경우
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)   # True (값이 같음)
print(a is b)   # False (다른 객체임)
print(a[0] is b[0])   # True (같은 객체임)
```

C와 Java에서의 문자열 비교
- C
  - strcmp() 함수를 사용해 문자열의 내용을 비교

- Java
  - ==연산자는 객체의 주소(참조)를 비교(python의 is연산자 역할)
  - equals() 메소드는 객체의 내용을 비교(python 의 ==연산자 역할)

사전 순서 비교
- 비교 연산자 < 사용
  - 유니코드를 비교
```python
def my_strcmp(s1, s2):
    if s1 < s2:
        return -1   # s1이 s2보다 사전 순서상 앞서는 경우
    elif s1 > s2:
        return 1    # s1이 s2보다 사전 순서상 나중인 경우
    else:
        return 0    # s1이 s2 문자열의 내용이 같은 경우
```
  - 문자열에 대한 < 연산은 유니코드 값에 대한 비교
  - 따라서 'Apple; < 'apple'도 True이고 'Zebra' < 'apple'도 True

문자열 숫자를 숫자로 변환
1. 문자열을 숫자로 변환하는 예
```python
a = int('123')
b = float('3.14')
c = int('A0', 16)   # 문자열 'A0'를 16진법으로 해석해서 변환
```

2. 숫자를 문자열로 변환하는 예
```python
a = str(123)
b = str(3.14)
```

### 패턴매칭
#### 고지식한 패턴 검색
고지식한 알고리즘(Brute Force)
- 단순한 방법
  - 본문 문자열을 처음부터 끝까지 차례대로 순화하면서 패턴 내의 문자들을 일일이 비교

구현
- 본문의 비교위치 i, 패턴에서의 비교위치 j
  - 일치하면 i, j 증가, 실패하면 i는 이전 시작위치 다음으로, j는 맨 앞으로 초기화

코드
```python
# p:찾을 패턴, t:본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
def brutee_force(p, t):
    i = 0   # t의 인덱스
    j = 0   # p의 인덱스
    M = len(p)
    N = len(t)
    while j < M and i < N:
        if t[i] != p[j]:    # 다른글자인 경우
            i = i - j + 1
            j = 0
        else:
          i += 1
          j += 1
    if j == M:
        return i - M    # 검색 성공
    else:
        return -1   # 검색 실패
```

시간복잡도
- 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
- 길이가 10,000인 문자열에서 길이 80인 패턴을 찾는 경우
  - 최악의 경우 약 10,000*80 = 800,000번의 비교가 필요

#### KMP 알고리즘
KMP 알고리즘
- 연구자인 Knuth, Morris, Pratt 세 사람의 이름에서 유래
- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
  - 불일치가 발생한 글자의 앞 부분에 어떤 문자가 있는지를 미리 알고 있게 됨
  - 조건에 따라, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않을 수 있음
  - 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 전처리가 필요

- 시간 복잡도
  - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 O(M)
  - 텍스트의 길이가 N일 때 검색은 최악의 경우 O(N)
  - 결과적으로 O(M+N)
  - 만약 M이 고정된 값으로 매우 짧다면 평균적으로 O(N)

아이디어
- 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황
  - 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용
t : abcdabcdabcef
p : abcdabcef

LPS(Longest Prefix which is also Suffix) 배열
- 접두사이자 접미사인 문자열의 최대 길이
- 일치하지 않을 때 비교할 인덱스
- 구현에 따라 next, pi 배열로도 불림

#### 보이어-무어 알고리즘
보이어-무어(Boyer-Moore) 알고리즘
- 상용 소프트웨어에서 채택하고 있는 알고리즘
- 실제 검색에서 매우 빠른 성능
  - 패턴 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이 만큼이 됨

불일치 문자 휴리스틱(Bad-Character Heuristic)
- 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
  - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프

Skip 배열

문자열 매칭 알고리즘 비교
- 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
- 고지식한 패턴 검색 알고리즘 : 수행시간 O(mn)
- 카프-라빈 알고리즘 : 수행시간 O(n)
- KMP 알고리즘 : 수행시간 O(n)
- 보이어-무어 알고리즘 : 수행시간 O(n)
  - 앞의 두 매칭 알고리즘들은 텍스트 문자열의 문자를 적어도 한번씩 훑기때문에 최선의 경우에고 O(n)
  - 보이버-무어 알고리즘은 텍스트 문자를 다 보지 않아도 됨
  - 패턴의 오른쪽부터 비교
  - 완전한 보이어-무어 알고리즘은 일치 접미부 휴리스틱을 함께 사용
  - 최악의 경우 O(mn)이지만 일반적으로 O(n)보다 시간이 덜 듬
  - grep, VS code, JVM 등에서 사용된다고 알려져 있음
  
#### 문자열 암호화
시저 암호(Caesar cipher)
- 줄리어스 시저가 사용했다고 하는 암호
- 시저는 기원전 100년경에 로마에서 활약했던 장군
- 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 [평행이동] 시킴으로써 암호화
- 1만큼 평행했을 때 1을 키 값이라고 함

단일 치환 암호화의 복호화
- 모든 키의 조합이 필요
- 키의 총 수
  - 26!
  - 1초에 10억개의 키를 적용할 수 있어도 120억년 이상 걸림

- 빈도 분석 공격 가능
  - 가장 많이 쓰이는 글자 E, T, A 등
  - 암호문에서 자주 나오는 문자를 추정해 대응시키면 해독 가능

문자열 압축
-Run-length encoding 알고리즘
  - 같은 값이 몇 번 반복되는가를 나타내는 방식
  - 이미지 파일 포맷 중 BMP 파일의 압축 방법 중 하나로 사용

- 허프만 코딩 알고리즘
  - 더 효율적이고 일반적인 압축 방법
  - 자주 나오는 문자는 짧은 코드, 드물게 나오는 문자는 긴 이진 코드를 부여해, 결과적으로 전체 데이터의 평균 비트 수를 최소화하는 알고리즘