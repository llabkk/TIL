### List
#### 카운팅 정렬(Counting Sort)
카운팅 정렬 : 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식
- 시간 복잡도 :  O(n+k), n은 리스트 길이, k는 정수의 최댓값

카운팅 정렬 제한 사항
1. 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
2. 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

카운팅 정렬 과정
1. data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 카운트 배열의 원소를 조정(누적합) : count[i] = count[i-1] + count[i]
3. data의 마지막 원소의 발생 횟수와 관련된 카운트 배열 원소를 1 감소시키고 temp[카운트배열원소]에 마지막 원소를 삽입

```python
def counting_sort(data, temp, k):
# data[] : 입력 배열(원소는 0이상 k이하 정수)
# temp[] : 정렬된 배열
# count[] : 카운트 배열

    count = [0] * (k+1)

    for i in range(len(data)):
        count[data[i]] += 1
    for i in range(1, k+1):
        count[i] += count[i-1]
    for i in range(len(data)-1, 0, -1):
        count[data[i]] -= 1
        temp[count[data[i]]] = data[i]
```

정렬 알고리즘 비교
알고리즘|평균 수행시간|최악 수행시간|알고리즘 기법|비고
|---|---|---|---|---|
버블 정렬|O(n^2)|O(n^2)|비교와 교환|코딩이 가장 손쉽다
카운팅 정렬|O(n+k)|O(n+k)|비교환 방식|n이 비교적 작을 때만 가능하다
선택 정렬|O(n^2)|O(n^2)|비교와 교환|교환의 회수가 버블, 삽입정렬보다 작다
퀵 정렬|O(n log n)|O(n^2)|분할 정복|최악의 경우 O(n^2)이지만, 평균적으로 가장 빠르다
삽입 정렬|O(n^2)|O(n^2)|비교와 교환|n의 개수가 작을 때 효과적이다
병합 정렬|O(n log n)| O(n log n)|분할 정복|연결리스트의 경우 가장 효율적인 방식

#### 완전 검색
완전 검색(exaustive search) : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- brute-force 혹은 generate-and-test 기법이라고도 불림
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출하는 방법으로 일반적으로 경우의 수가 상대적으로 작을 때 유용함

완전 검색의 필요성
- 완전검색으로 시작
  - 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
  -자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는것이 바람직

순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열 : nPr
- nPr은 다음과 같은 식이 성립
  - nPr = n*(n-1)*(n-2)*...*(n-r+1)
- nPn = n!이라고 표기하며 Factorial이라 부름

순열 예시
```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i2 ans i3 != i1:
                    print(i1, i2, i3)

import itertools
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
nPr = list(itertools.permutations(arr, 6))
for x in nPr:
    print(x)
print(len(nPr))
```

#### 탐욕 알고리즘
탐욕 알고리즘(greedy) : 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방식

탐욕 알고리즘 특징
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 greedy 접근임

탐욕 알고리즘 과정
1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해선택부터 다시 시작한다.