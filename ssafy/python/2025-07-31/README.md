### 상속
#### 상속 기본 개념
상속 : 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것

상속이 필요한 이유
1. 코드 재사용
  - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
  - 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음
2. 계층 구조
  - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
  - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
3. 유지 보수의 용이성
  - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
  - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음

상속 예시
```
class Animal:
  def eat(self):
    print('먹는중')

# 상속하기 위해서는 부모 클래스 이름을 함께 선언
class Dog(Animal):
  def bark(self):
    print('멍멍')
```

#### 클래스 상속
상속없이 구현하는 경우
- 상속이 없이 구현하는 경우 각각의 고유 속성을 표현하기 어려움
- 다른 클래스로 각각 선언하여 구현하여 분리하면, 메서드가 중복으로 정의될 수 있음

#### 메서드 오버라이딩
메서드 오버라이딩 : 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의 하는 것(덮어쓰기)
```
class Animal:
  def eat(self):
    print('animal이 먹는 중')

class Dog:
  def eat(self):
    print('dog이 먹는 중')

my_dog = Dog()
my_dog.eat() # dog이 먹는 중
```

[참고] 오버로딩(overloading)
- 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것(파이썬은 미지원)

#### 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있음
- 상속받은 모든 클래스의 요소를 활용 가능
- 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정

```
class Person:
  def __init__(self, name):
    self.name = name

  def greeting(self):
    return f'안녕, {self.name}'

class Mom(Person):
  gene = 'xx'

  def swim(self):
    return '엄마가 수영'

class Dad(Person):
  gene = 'xy'

  def walk(self):
    return '아빠가 걷기'

class FirstChild(Dad, Mom):
  def swim(self):
    return '첫째가 수영'
  
  def cry(self):
    return ' 첫째가 응애'

baby1 = FirstChild('아가')
print(baby1.cry())    # 첫째가 응애
print(baby1.swim())   # 첫째가 수영
print(baby1.walk())   # 아빠가 걷기
print(baby1.gene)     # xy
```

다이아몬드 문제1|상위
|---|---|
A|
B(A)|C(A)
D(B,C)|
하위|

D에서부터 탐색하는 경우 순서(MRO)
- D->B->C->A

다이아몬드 문제2|상위
|---|---|
A|
B(A)|C()
D(B,C)|
하위|

D에서부터 탐색하는 경우 순서(MRO)
- D->B->A->C

print(D.mro()) 혹은 print(D.__mro__)를 통해 mro 순서 확인 가능

파이썬의 해결책
- MRO 알고리즘을 사용하여 클래스 목록을 생성
- 부모 클래스로부터 상속된 속성을 정해진 내부 알고리즘에 따라 검색
- 이 순서는 기본적으로 왼쪽에서 오른쪽으로 진행되며, 계층 구조에서 중복되는 클래스는 한 번만 확인
- 속성이 D에서 발견되지 않으면 B에서 찾고, 거기에서도 발견되지 않으면 C에서 찾고 이런식으로 진행

#### super() 메서드
super() : 메서드 해석 순서(mro)에 따라, 현재 클래스의 부모(상위) 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수

super() 특징
- 단순히 부모 클래스의 메서드를 호출하기 위한 용도 뿐만 아니라, 다중 상속이 있을 때도 올바른 순서(mro)에 따라 상위 클래스의 메서드를 찾아 실행

super()의 2가지 사용 사례
1. 단일 상속 구조
  - 명시적으로 부모 클래스 이름을 적지 않아도 부모 메서드를 안전하게 호출할 수 있음
  - 나중에 부모 클래스의 이름이 바뀌거나 상속 구조가 변경되어도 super() 호출 부분을 그대로 사용할 수 있어서 유지보수성이 향상
2. 다중 상속 구조
  - mro에 따라 각 클래스의 메서드를 찾아가기 때문에, 단순히 직계 부모만이 아니라 다중 상속 관계에서도 적절한 상위 클래스의 메서드를 안전하게 호출 가능
  - 복잡한 상속 구조에서도 코드를 유연하고 깔끔하게 유지할 수 있음

mro가 필요한 이유
- 부모 클래스들이 여러 번 액세스 되지 않도록, 각 클래스에서 지정된 왼쪽에서 오른쪽으로 가는 순서를 보존하고, 각 부모를 오직 한 번만 호출하고, 부모들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조 형성

### 에러와 예외
#### 디버깅
버그
- 소프트웨어에서 발생하는 오류 또는 결함
- 프로그램의 예상된 동작과 실제 동작 사이의 불일치

디버깅
- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- 프로그램의 오작동 원인을 식별하여 수정하는 작업

디버깅 방법
1. print() 함수 활용
2. 개발 환경(text editor, IDE)등에서 제공하는 기능 활용
3. python tutor 활용
4. 뇌 컴파일, 눈 디버깅

#### 에러
에러 : 프로그램 실행 중에 발생하는 예외 상황

1. 문법 에러(syntax error) : 프로그램의 구문이 올바르지 않은 경우 발생(오타, 괄호 및 콜론 누락 등의 문법적 오류)
- 실행되지 않음

2. 예외(exception) : 프로그램 실행 중에 감지되는 에러

#### 예외
예외
- 프로그램이 잘못된 동작을 시도할 때 자동으로 감지됨
- 프로그램은 즉시 종료됨

내장 예외 : 예외 상황을 나타내는 예외 클래스들
- 내장 예외는 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용

#### 예외 처리
예외처리 : 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법
- 예외 처리를 통해 오류가 발생해도 프로그램의 흐름을 안전하게 이어갈 수 있음

예외처리 사용 구문
- try
  - 예외가 발생할 수 있는 코드 작성
- except
  - 예외가 발생했을 때 실행할 코드 작성
- else
  - 예외가 발생하지 않았을 때 실행할 코드 작성
- finally
  - 예외 발생 여부와 상관없이 항상 실행할 코드 작성

#### try & except
```
# try-except 구조
# 예외가 발생할 수 있는 코드
try:
    num = int(input('숫자를 입력하세요: '))
# 예외 처리 코드
except ValueError:
    print('숫자를 입력해주세요!')
```

#### 복수 예외 처리
```
# 복수 예외처리
try:
    num = int(input('100을 나눌 값을 입력하시오 : '))
    print(100 / num)
except (ValueError, ZeroDivisionError):
    print('제대로 입력해주세요.')


try:
    num = int(input('100을 나눌 값을 입력하시오 : '))
    print(100 / num)
except ValueError:
    print('숫자를 넣어주세요.')
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except:
    print('에러가 발생했습니다.')
```

#### else & finally
- else 블록은 예외가 발생하지 않았을 때 추가 작업을 진행
- finally 블록은 예외 발생 여부와 상관없이 항상 실행할 코드를 작성
```
try:
    x = int(input('숫자를 입력하세요: '))
    y = 10 / x
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except ValueError:
    print('유효한 숫자가 아닙니다.')
else:
    print(f'결과: {y}')
finally:
    print('프로그램이 종료되었습니다.')
```

### 참고
#### 예외 처리 주의사항
- Exception은 모든 예외사항의 부모 class
- except Exception을 사용하면 모든 예외 사항을 먼저 가로채므로 아래 except 코드는 실행되지 않음
- 항상 범용적인 예외 처리는 마지막에 두어야 함
- 내장 예외 클래스의 상속 계층구조를 따라서 하위 클래스를 먼저 확인할 수 있도록 작성

#### 예외 객체 다루기
as 키워드
- 예외 객체 : 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
- except 블록에서 예외 객체를 받아 상세한 예외 정보를 활용 가능

#### EAFP & LBYL
EAFP(Easier to Ask for Forgiveness than Permission)
- 예외처리를 중심으로 코드를 작성하는 접근 방식(try-except)

LBYL(Look Before You Leap)
- 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)

접근 방식 비교
EAFP|LBYL
|---|---|
"일단 실행하고 예외를 처리"|"실행하기 전에 조건을 검사
코드를 실행하고 예외가 발생하면 예외처리를 수행|코드 실행 전에 조건문 등을 사용하여 예외 상황을 미리 검사하고, 예외 상황을 피하는 방식
코드에서 예외가 발생할 수 있는 부분을 미리 예측하여 대비하는 것이 아니라, 예외가 발생한 후에 예외를 처리|코드가 좀 더 예측 가능한 동작을 하지만, 코드가 더 길고 복잡해질 수 있음
예외 상황을 예측하기 어려운 경우에 유용|예외 상황을 미리 방지하고 싶을 때 유용

#### 클래스의 의미와 활용
클래스 사용의 효능
- 프로그램의 규모가 커지면 서로 관련 있는 정보와 기능을 따로 관리하기 어려워짐
- 클래스를 사용하면 관련 데이터와 기능을 '한 덩어리'로 묶어 구조를 명확히 할 수 있음
- 작성한 코드가 깔끔해지고, 나중에 수정하거나 기능을 추가할 때 더 쉽고 안전해짐

