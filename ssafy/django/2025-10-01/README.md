## 오전
### Login
- 클라이언트와 서버 간의 상태 정보를 유지하기 위해서 쿠키와 세션을 사용
- 클라이언트와 서버는 각기 다른 사용자를 식별해야 하는 상태
- 서버에 '나'임을 인증하는 과정이 바로 'Login'

로그인 정보 입력 built-in form: AuthenticationForm 활용(forms.Form 상속)

사용시 주의사항
- (request=request,data=request.POST)
- 입력받는 정보를 기반으로 로그인하여 세션을 만드는 login 함수를 활용

login(request, user)
- AuthenticationForm를 통해 인증된 사용자를 로그인 하는 함수
- login(request, form.get_user())

get_user()
- AuthenticationForm의 인스턴스 메서드

### Logout
Logout
- 로그아웃은 Session을 Delete하는 과정
- 서버의 세션 데이터를 비우고, 클라이언트의 세션 쿠키를 삭제

logout(request)
1. DB에서 현재 요청에 대한 Session Data를 삭제
2. 클라이언트의 쿠키에서도 Session Id를 삭제

### AbstractUser class
Abstract base classes(추상 기본 클래스)
- 몇 가지 공통 정보를 여러 다른 모델에 넣을 때 사용하는 클래스
- 데이터베이스 테이블을 만드는 데 사용되지 않으며, 대신 다른 모델의 기본 클래스로 사용되는 경우 해당 필드가 하위 클래스의 필드에 추가 됨
- 인증에 필요한 최소한의 기능만 제공

AbstractUser class
- 관리자 권한과 함께 **완전한 기능**을 가지고 있는 User model을 구현하는 추상 기본클래스
- 기본 User 모델이 가진 모든 필드가 이미 구변되어 있음

추상 기본 클래스(Abstract Base class) 정리
구분|AbstractBaseUser|AbstractUser
---|---|---
제공 필드|최소한의 인증 필드(비밀번호, last_login 등)|기본 User 모델의 모든 필드(username, email 등)
장점|최대의 유연성과 자유도|개발 속도가 빠르고 편리함
사용 케이스|이메일이 아닌 전화번호 등으로 로그인하는 등, 완전히 새로운 인증 체계를 만들 때|기존 인증 방식은 유지하면서 프로필 사진, 닉네임 등 필드만 추가하고 싶을 때(대부분의 경우)
예시|기본 피자 도우|토핑이 올려진 피자

### 회원 가입
회원 가입
- User 객체를 Create 하는 과정
- 사용자로부터 아이디, 비밀번호 등의 정보를 입력받아, DB에 새로운 User 객체를 생성하고 저장

get_user_model(): 현재 프로젝트에서 활성화 된 사용자 모델(active user model)을 반환하는 함수
- Django는 User모델을 직접 참조하는 것을 권장하지 않음

### 회원 탈퇴
- request.user.delete()를 활용해서 유저 객체 삭제를 진행

### 인증된 사용자에 대한 접근 제한
#### is_authenticated 속성
1. is_authenticated 속성
- 사용자가 인증 되었는지 여부를 알 수 있는 User model의 읽기 전용 속성
- 인증 사용자에 대해서는 항상 True, 비인증 사용자에 대해서는 False
- 사용되는 경우
  - 사용자의 로그인 상태에 따라 다른 메뉴를 보여줄 때
  - view 함수 내에서 특정 기능을 로그인한 사용자에게만 허용하고 싶을 때
- 보이지만 않을 뿐 주소를 알면 접속가능

#### login_required 데코레이터
2. login_required 데코레이터
- 인증된 사용자에 대해서만 view 함수를 실행 시키는 데코레이터
- 비인증 사용자의 경우 /accounts/login/ 주소로 redirect 시킴
- 사용되는 경우
  - 게시글 작성, 댓글 달기 등 누가 작성했는지 중요한 곳에 사용

### 참고
#### is_authenticated 코드
- 메서드가 아닌 속성 값임을 주의

#### 회원가입 후 자동 로그인
- 회원가입 성공한 user 객체를 활용해 login 진행

#### 회원 탈퇴 개선
탈퇴와 함께 기존 사용자의 Session Data 삭제 방법
- 사용자 객체 삭제 이후 로그아웃 함수를 호출해야 함
- 단, 탈퇴(1) 후 로그아웃(2)의 순서가 바뀌면 안됨

## 오후
### 회원정보 수정
- User 객체를 Update 하는 과정
- 수정할 대상 User 객체를 가져오고, 입력받은 새로운 정보로 기존 내용을 갱신

### 비밀번호 변경
- 인증된 사용자의 Session 데이터를 Update하는 과정
- 기존 비밀번호를 통해 사용자를 인증하고, 새로운 비밀번호를 암호화하여 갱신

###  세션 무효화 방지
암호 변경 시 세션 무효화
- 비밀번호가 변경되면 기존 세션과의 회원 인증 정보가 일치하지 않게 되어 버려 로그인 상태가 유지되지 못하고 로그아웃 처리됨
- 비밀번호가 변경되면서 기존 세션과의 회원 인증 정보가 일치하지 않기 때문

### 비밀번호 암호화
암호화의 중요성
- 많은 해킹사태가 발생하고 있고, 데이터가 유출되더라도 그 내용을 알 수 없도록 하는 암호화는 특히 중요

비밀번호의 저장 방식
1. 사용자가 입력한 비밀번호 그대로 저장하는 방식 => 보안에 매우 취약하므로 X
2. 일정한 규칙에 따라 비밀번호를 알아볼 수 없는 문자로 인코딩 한 후 저장 => 보안에 매우 취약하므로 X
3. 비밀번호를 복원이 불가능한 고정된 길이의 문자열로 변환 후 저장 => 보안에 필수
  - 데이터베이스가 유출되어도 공격자는 복잡하게 얽힌 문자열을 보게 되고, 복원이 불가능하기 때문에 실제 비밀번호를 알 수 없음
  - 악의적인 내부 직원이 비밀번호를 보더라도 암호화된 비밀번호를 보게 되므로, 실제 비밀번호를 유추할 수 없음
  - 비밀번호를 복원이 불가능한 고정된 길이로 바꾸는 과정을 해시라고 함

고정된 길이의 문자열로 변환하는 이유
- 보안성: 변환된 문자열의 길이가 다르다면, 길이만 보고도 원래 비밀번호의 길이를 유추할 수 있음
- 일관성: 길이가 동일하기 때문에 저장 공간을 예측하고 설계하기 쉬우며, 검색/비교하는 처리 속도도 일정하게 유지할 수 있음

해시(Hash): 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것
- 작은 변화에도 해시값이 크게 달라지는 특성으로 인해 변조 여부를 쉽게 확인할 수 있음
- 입력값이 들어오더라도 해시 함수에 의해서 다른 값으로 바뀌며, 동일한 값은 항상 동일한 해시값을 생성

해시함수(Hash function): 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수
- 어떤 길이의 데이터든 넣을 수 있고, 항상 고정된 길이의 결과물(해시 값)이 나옴
- 입력 값으로 해시 값을 만들 수는 있지만, 해시 값만 보고 원래 입력값을 알아낼 수 없음(단방향)
- 입력 값이 단 한 글자만 달라져도 해시 값은 완전히 달라짐(눈사태 효과)
- 같은 입력 값을 넣으면 언제나 똑같은 해시 값이 나옴

Django는 기본적으로 SHA-256 해시 함수를 사용해서 암호화

SHA-256: 안전한 해시 알고리즘으로, 어떤 데이터를 입력하든 256비트 길이의 결과물을 만들어 냄

레인보우 테이블(rainbow table) 공격
- 공격자가 자주 사용되는 비밀번호들을 미리 수백만, 수십억 개를 해시로 변환해 저장해 둔 거대한 정답지
- 공격 방식
  1. 공격자가 DB를 탈취해 사용자의 비밀번호 해시 값을 얻음
  2. 해시 값을 공격자 자신의 레인보우 테이블에서 검색
  3. 테이블에서 일치되는 값을 찾아내면서, 역방향으로 되돌리지 않고 비밀번호를 알아내는 데 성공

솔트(Salt)
- 각 사용자마다 고유하게 생성된 임의의 문자열(솔트)을 비밀번호에 덧붙여서 해시 값을 생성
- 이 솔트(Salt)는 해시 값과 함께 데이터베이스에 저장

무차별 대입 공격(Brute-force Attack)
- 가장 원시적이지만 강력한 방법으로써 가능한 모든 비밀번호를 하나씩 대입하는 방식
- 이 공격은 시간과의 싸움이며, 현대 컴퓨터의 빠른 연산 속도가 공격자의 무기가 됨
- 솔트를 파악한 상태에서 사용

키 스트레칭(Key Stretching)
- 솔트(Salt)를 적용한 해시 함수를 수만 ~ 수십만 번 반복하여 연산 시간을 의도적으로 늘리는 기법
- '속도'가 무기인 무차별 대입 공격을 방어할 수 있음
- Django는 이 키 스트레칭을 구현하기 위해서 PBKDF2라는 검증된 알고리즘을 기본으로 사용
  - 최근에는 더 강력한 보안을 제공하는 Argon2, bcrypt 같은 알고리즘도 지원

Django에서의 비밀번호 암호화
<algorithm>$<iterations>$<salt>$<hash>
1. <algorithm>: 어떤 알고리즘을 쓰는 지
2. <iterations>: 키 스트레칭 횟수
3. <salt>: 생성된 솔트
4. <hash>: 생성된 최종 해시

비밀번호 암호화 정리
- 암호화 과정을 이해한 후, 검증된 프레임워크의 보안 기능을 신뢰하고 사용하기
  - 보안은 매우 어렵고 복잡한 분야이며, Django 공식에서도 가급적 재발명하지 않을 것을 권장하고 있음
- 단순히 코드를 복사해서 붙여넣는 것을 넘어, 이 기능이 왜 이렇게 만들어졌는지 이해하면, 더 견고하고 안전한 어플리케이션을 만들 수 있음
- 사용자는 우리의 서비스를 믿고 소중한 개인정보를 맡기고, 그들의 데이터를 안전하게 지키는 것은 개발자의 '가장 기본적인 책임이자 직업윤리'

### 참고
#### 비밀번호 초기화
- 비밀번호를 잊어버린 사용자가 이메일을 활용하여 비밀번호를 다시 설정하는 과정
- 비밀번호 초기화 과정
  1. 비밀번호를 찾으려고 하는 이메일 입력
  2. 이메일로 비밀번호 재설정 링크를 전송
  3. 비밀번호 재설정 페이지에서 새로운 링크를 전송
  4. 초기화 후 다시 로그인

#### PasswordChangeForm 인자 순서
PasswordChangeForm이 다른 Form과 달리 user 객체를 첫번째 인자로 받는 이유
  - 부모 클래스인 SetPasswordForm의 생성자 함수 구성을 따르기 때문
